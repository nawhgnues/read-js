### Comparisons

### 불린형 반환

다른 연산자와 마찬가지로 비교 연산자 역시 값을 반환한다.
반환 값은 불린형.

- true가 반환되면, "긍정", "참", "사실"을 의미한다.
- false가 반환되면, "부정", "거짓", "사실이 아님"을 의미한다.

```
alert( 2 > 1 );  // true
alert( 2 == 1 ); // false
alert( 2 != 1 ); // true
```

### 문자열 비교

자바스크립트는 '사전' 순으로 문자열을 비교한다.

- 사전 뒤쪽의 문자열은 사전 앞쪽의 문자열보다 크다고 판단.

```
alert( 'Z' > 'A' ); // true
alert( 'Glow' > 'Glee' ); // true
alert( 'Bee' > 'Be' ); // true
```

문자열 비교 시 적용되는 알고리즘은 다음과 같다.

1. 두 문자열의 첫 글자를 비교.

2. 첫 번째 문자열의 첫 글자가 다른 문자열의 첫 글자보다 크면(작으면), 첫 번째 문자열이 두 번째 문자열보다 크다고(작다고) 결론 내고 비교를 종료.

3. 두 문자열의 첫 글자가 같으면 두 번째 글자를 같은 방식으로 비교.

4. 글자 간 비교가 끝날 때까지 이 과정을 반복.

5. 비교가 종료되었고 문자열의 길이도 같다면 두 문자열은 동일하다고 결론낸다. 비교가 종료되었지만 두 문자열의 길이가 다르면 길이가 긴 문자열이 더 크다고 결론 낸다.

※ 정확히는 사전 순이 아닌 유니코드 순이다.

### 다른 형을 가진 값 간의 비교

비교하려는 값의 자료형이 다르면 자바스크립트는 이 값들을 숫자형으로 바꾼다.

```
alert( '2' > 1 ); // true, 문자열 '2'가 숫자 2로 변환된 후 비교가 진행.
alert( '01' == 1 ); // true, 문자열 '01'이 숫자 1로 변환된 후 비교가 진행.
```

불린 값의 경우는 true는 1, false는 0으로 변환된 후 비교가 이뤄진다.

```
alert( true == 1 ); // true
alert( false == 0 ); // true
```

### 일치 연산자

동등 연산자(equality operator) `==`은 `0`과 `false`를 구별하지 못한다.

피연산자가 빈 문자열일 때도 같은 문제가 발생한다.

이런 문제는 동등 연산자가 형이 다른 피연산자를 비교할 때 피연산자를 숫자형으로 바꾸기 때문에 발생한다.

빈 문자열과 false는 숫자형으로 변환하면 0이 된다.

일치 연산자(strict equality operator) === 를 사용하면 형 변환 없이 값을 비교할 수 있다.

일치 연산자는 엄격한(strict) 동등 연산자이다.
자료형의 동등 여부까지 검사하기 때문에 피연산자 a와 b의 형이 다를 경우 a === b는 즉시 false를 반환한다.

일치 연산자 ===가 동등 연산자 ==의 엄격한 버전인 것처럼 ‘불일치’ 연산자 !==는 부등 연산자 !=의 엄격한 버전.

일치 연산자는 동등 연산자보다 한 글자 더 길긴 하지만 비교 결과가 명확하기 때문에 에러가 발생할 확률을 줄여준다.

### null이나 undefined와 비교하기

##### 일치 연산자 ===를 사용하여 null과 undefined를 비교

- 두 값의 자료형이 다르기 때문에 일치 비교 시 거짓이 반환.

```
alert( null === undefined ); // false
```

##### 동등 연산자 ==를 사용하여 null과 undefined를 비교

- 동등 연산자를 사용해 null과 undefined를 비교하면 특별한 규칙이 적용돼 true가 반환된다.

동등 연산자는 null과 undefined를 '각별한 커플’처럼 취급하기 때문에 두 값은 자기들끼리는 잘 어울리지만 다른 값들과는 잘 어울리지 못한다.

```
alert( null == undefined ); // true
```

##### 산술 연산자나 기타 비교 연산자 <, >, <=, >=를 사용하여 null과 undefined를 비교

- null과 undefined는 숫자형으로 변환된다. null은 0, undefined는 NaN으로 변한다.

### null vs 0

```
alert( null > 0 );  // (1) false
alert( null == 0 ); // (2) false
alert( null >= 0 ); // (3) true
```

이런 결과가 나타나는 이유는 동등 연산자 ==와 기타 비교 연산자 <, >, <=, >=의 동작 방식이 다르기 때문이다.

(1)에서 null > 0이 거짓을, (3)에서 null >= 0이 참을 반환하는 이유는 (기타 비교 연산자의 동작 원리에 따라) null이 숫자형으로 변환돼 0이 되기 때문.

그런데 동등 연산자 ==는 피연산자가 undefined나 null일 때 형 변환을 하지 않는다. undefined와 null을 비교하는 경우에만 true를 반환하고, 그 이외의 경우(null이나 undefined를 다른 값과 비교할 때)는 무조건 false를 반환한다. 이런 이유 때문에 (2)는 거짓을 반환한다.

### 비교가 불가능한 undefined

undefined를 다른 값과 비교해서는 안된다.

```
alert( undefined > 0 ); // false (1)
alert( undefined < 0 ); // false (2)
alert( undefined == 0 ); // false (3)
```

위 예시를 보면 undefined은 항상 false를 반환한다.

이런 결과는 아래와 같은 이유 때문에 발생한다.

(1)과(2)에선 undefined가 NaN으로 변환되는데(숫자형으로의 변환), NaN이 피연산자인 경우 비교 연산자는 항상 false를 반환한다.

undefined는 null이나 undefined와 같고, 그 이외의 값과는 같지 않기 때문에 (3)은 false를 반환한다.

### 함정 피하기

- 일치 연산자 ===를 제외한 비교 연산자의 피연산자에 undefined나 null이 오지 않도록 특별히 주의.

- undefined나 null이 될 가능성이 있는 변수가 <, >, <=, >=의 피연산자가 되지 않도록 주의.

만약 변수가 undefined나 null이 될 가능성이 있다고 판단되면, 이를 따로 처리하는 코드를 추가한다.

### 요약

- 비교 연산자는 불린값을 반환.
- 문자열은 문자 단위로 비교되는데, 이때 비교 기준은 ‘사전’ 순.
- 서로 다른 타입의 값을 비교할 땐 숫자형으로 형 변환이 이뤄지고 난 후 비교가 진행(일치 연산자는 제외).
- null과 undefined는 동등 비교(==) 시 서로 같지만 다른 값과는 같지 않다.
- null이나 undefined가 될 확률이 있는 변수가 > 또는 <의 피연산자로 올 때는 주의. null, undefined 여부를 확인하는 코드를 따로 추가하는 습관을 들이길 권유합니다.
